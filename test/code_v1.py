import matplotlib.pyplot as plt
import numpy as np
from tqdm import tqdm

"""
    Implement Metropolis Algorithm
    Introduction: 
        The Metropolis algorithm is a widely used Monte Carlo simulation that dynamically guides
    a given spin configuration towards thermal equilibrium. The steps needed to write the
    algorithm can be briefly outlined as follows:
    
        Step 1: Generate a random initial spin configuration {sigma_i}^N_{i=1} with energy E0;
        Step 2: Flip a random spin (sigma_k to sigma_k) and calculate the energy E_t of this trial state;
                However, the way to calculate E_t and get ΔE is too costly,. 
                Another popular way to calculate local difference is taken in the algorithm.  
        Step 3: Calculate the difference in energy generated by the spin flip, ΔE = E_t - E_0, 
                and the associated transition probability p = exp(-beta*ΔE)
                - If DeltaE <= 0, then we accept the spin flip 
                    because the trial spin configuration is energetically favoured over the initial state;
                - If DeltaE > 0, then we compare the transition probability p to a random number r.
                    We accept the new configuration if r <= p. Otherwise, we keep the spin unflipped.
        Step 4: Update the average energy, magnetization, etc.
        Step 5: Repeat steps (2) to (4) with the chosen spin configuration until thermal equilibrium has been reached.

"""


# ============================================================
# Step 1: Generate a random initial spin configuration (begin)
# ============================================================
def initialize_lattice(N, mode="cold"):
    """
        The function is to initialize a 2D Ising lattice with uniform mode(+1) or random mode(+1/-1)

        Parameters
        ----------
            N: int
                the size of the lattice (N, N)
            mode: str
                random or uniform

        Returns
        ----------
             lattice: numpy array
                initialized lattice
    """
    if mode == "cold":
        lattice =  np.ones((N, N), dtype=int)
    elif mode == "hot":
        lattice =  np.random.choice([1, -1], size=(N, N))
    else:
        raise ValueError(f"Unrecognized mode: {mode}; must be either 'cold' or 'hot'")
    return lattice
# ============================================================
# Step 1: Generate a random initial spin configuration (end)
# ============================================================



# ============================================================
# Step 2: Calculate the dE of (begin)
# ============================================================
def compute_energy_change(lattice, i, j):
    """
    Calculate the change in energy (dE) for flipping a single spin
    at position (i, j) in a 2D nearest-neighbor Ising model
    with periodic boundary conditions and coupling J = 1.

    Parameters
    ----------
    lattice : np.ndarray
        The 2D lattice of spins with shape (N, N).
    i : int
        Row index of the spin.
    j : int
        Column index of the spin.

    Returns
    -------
    dH : float
        Energy difference ΔE = E_new - E_old for flipping s_{i,j}.
    """
    N = lattice.shape[0]
    spin = lattice[i, j]

    # Periodic boundary conditions: neighbors up, down, left, right
    up    = lattice[(i - 1) % N, j]
    down  = lattice[(i + 1) % N, j]
    left  = lattice[i, (j - 1) % N]
    right = lattice[i, (j + 1) % N]

    neighbors = up + down + left + right

    # For E = -sum_{<i,j>} s_i s_j, flipping one spin gives
    # ΔE = 2 * s_ij * sum_{nn} s_nn
    dE = 2.0 * spin * neighbors

    return dE
# ============================================================
# Step 2: Calculate the dE_t flipped spin (end)
# ============================================================


# ============================================================
# Step 3: Single update of Metropolis, repeat it for each sweep. (begin)
# ============================================================
def metropolis_single_flip(lattice, beta):
    """
    Perform a single Metropolis trial:
    - choose a random spin
    - compute ΔE
    - accept/reject according to Metropolis rule.

    Warning the function also change the pointer so the info in the lattice pointer is already changed
    """

    N = lattice.shape[0]

    # Step 2: flip a random spin, conceptually
    i, j = np.random.randint(0, N, size=2)

    # Compute Energy change of flipped spin
    dE = compute_energy_change(lattice, i, j)


    # Metropolis
    if dE <= 0:
        # Energetically favourable: always accept
        lattice[i, j] *= -1
    else:
        # Accept with probability p = exp(-β ΔE)
        p = np.exp(-beta * dE)
        if np.random.rand() < p:
            lattice[i, j] *= -1
    return lattice

def metropolis_update(lattice, beta):
    """
    Perform one Metropolis *sweep* on the lattice.

    A sweep consists of N*N single-spin Metropolis trials, where
    N is the linear system size.

    Parameters
    ----------
    lattice : np.ndarray
        The 2D lattice of spins.
    beta : float
        Inverse temperature (1 / T).

    Returns
    -------
    lattice : np.ndarray
        Updated lattice after one sweep.
    """
    N = lattice.shape[0]

    # one sweep: try N^2 flips
    for _ in range(N * N):
        metropolis_single_flip(lattice, beta)

    return lattice
# ============================================================
# Step 3: single update of Metropolis, repeat it for each sweep. (end)
# ============================================================



# ============================================================
# Step 4: Average magnetization (begin)
# ============================================================

def compute_magnetization(lattice):
    """
    Calculate the total magnetization of the lattice.

    Parameters
    ----------
    lattice : np.ndarray
        The 2D lattice of spins.

    Returns
    -------
    M : float
        Total magnetization M = sum_{i,j} s_{i,j}.
    """
    return np.sum(lattice,dtype=np.float64)


# Metropolis simulation
def simulate_ising(N, beta_range, n_samples, tol):
    """
    Simulate the Ising model using Metropolis algorithm and compute observables.
    Parameters:
        N (int): Lattice size (N x N).
        beta_range (list): Range of inverse temperatures (1/T).
        n_samples (int): Number of samples to compute observables.
        tol (float): Tolerance for error calculation.
    Returns:
        list, list: Mean magnetizations squared and their errors for each beta.
    """
    magnetizations = []
    errors = []

    for beta in tqdm(beta_range, desc="Metropolis Simulating"):
        lattice = initialize_lattice(N, mode="cold")

        # Thermalize the lattice, repeat 1000 times update
        for _ in range(1000):
            lattice = metropolis_update(lattice, beta)

        # Sampling
        squared_magnetization = []
        for _ in range(n_samples):
            lattice = metropolis_update(lattice, beta)
            magnetization = compute_magnetization(lattice)
            squared_magnetization.append(magnetization**2)

        # Compute mean and variance
        mean_squared_magnetization = np.mean(squared_magnetization)
        var_squared_magnetization = np.var(squared_magnetization)
        error = np.sqrt(var_squared_magnetization / n_samples)

        magnetizations.append(mean_squared_magnetization)
        errors.append(error)

    return magnetizations, errors



def plot_data(dats, legs, xlab, ylab):
    ''' Plot the data in the list of lists dats. '''
    pass


def plot_results(beta_range, magnetizations, errors, N):
    """
    Plot magnetization squared vs temperature with error bars.
    """
    temperatures = 1 / np.array(beta_range)
    plt.errorbar(temperatures, magnetizations, yerr=errors, fmt='o', label=f"N={N}")
    plt.xlabel("Temperature (T)")
    plt.ylabel(r"$\mathbb{E}[M^2(S)]$")
    plt.title("Magnetization vs Temperature")
    plt.legend()
    plt.grid()
    plt.show()


# Critical temperature vs lattice size
def critical_temperature_vs_size(N_values, beta_range, n_samples, tol):
    """
    Plot critical temperature (Tc) as a function of lattice size N^2.
    """
    Tc_values = []
    for N in N_values:
        magnetizations, _ = simulate_ising(N, beta_range, n_samples, tol)
        Tc = 1 / beta_range[np.argmax(np.gradient(magnetizations))]
        Tc_values.append(Tc)

    plt.plot(N_values, Tc_values, marker='o')
    plt.xlabel(r"Lattice Size $N^2$")
    plt.ylabel("Critical Temperature (Tc)")
    plt.title("Critical Temperature vs Lattice Size")
    plt.grid()
    plt.show()

# Main execution
if __name__ == "__main__":
    N = 20  # Lattice size
    beta_range = np.linspace(0.2, 2, 50)  # Range of inverse temperatures
    n_samples = 500  # Number of samples for averaging
    tol = 0.01  # Error tolerance

    # Simulate and plot magnetization vs temperature
    magnetizations, errors = simulate_ising(N, beta_range, n_samples, tol)
    plot_results(beta_range, magnetizations, errors, N)

    # Critical temperature vs lattice size
    N_values = [10, 20, 30, 40]
    critical_temperature_vs_size(N_values, beta_range, n_samples, tol)