import matplotlib.pyplot as plt
import numpy as np
from tqdm import tqdm

"""
    Implement Metropolis Algorithm
    Introduction: 
        The Metropolis algorithm is a widely used Monte Carlo simulation that dynamically guides
    a given spin configuration towards thermal equilibrium. The steps needed to write the
    algorithm can be briefly outlined as follows:

        Step 1: Generate a random initial spin configuration {sigma_i}^N_{i=1} with energy H0;
        Step 2: Flip a random spin (sigma_k to sigma_k) and calculate the energy H_t of this trial state;
                However, the way to calculate E_t and get ΔE is too costly,. 
                Another popular way to calculate local difference is taken in the algorithm.  
        Step 3: Calculate the difference in energy generated by the spin flip, ΔH = H_t - H_0, 
                and the associated transition probability p = exp(-beta*ΔH)
                - If DeltaE <= 0, then we accept the spin flip 
                    because the trial spin configuration is energetically favoured over the initial state;
                - If DeltaE > 0, then we compare the transition probability p to a random number r.
                    We accept the new configuration if r <= p. Otherwise, we keep the spin unflipped.
        Step 4: Update the average energy, magnetization, etc.
        Step 5: Repeat steps (2) to (4) with the chosen spin configuration until thermal equilibrium has been reached.

"""


# ============================================================
# Step 1: Generate a random initial spin configuration (begin)
# ============================================================
def initialize_lattice(N, mode="cold"):
    """
        The function is to initialize a 2D Ising lattice with uniform mode(+1) or random mode(+1/-1)

        Parameters
        ----------
            N: int
                the size of the lattice (N, N)
            mode: str
                random or uniform

        Returns
        ----------
             lattice: numpy array
                initialized lattice
    """
    if mode == "cold":
        lattice = np.ones((N, N), dtype=int)
    elif mode == "hot":
        lattice = np.random.choice([1, -1], size=(N, N))
    else:
        raise ValueError(f"Unrecognized mode: {mode}; must be either 'cold' or 'hot'")
    return lattice


# ============================================================
# Step 1: Generate a random initial spin configuration (end)
# ============================================================


# ============================================================
# Step 2: Calculate the dH of (begin)
# ============================================================
def compute_energy_change(lattice, i, j):
    """
    Calculate the change in energy (dH) for flipping a single spin
    at position (i, j) in a 2D nearest-neighbor Ising model
    with periodic boundary conditions and coupling J = 1.

    Parameters
    ----------
    lattice : np.ndarray
        The 2D lattice of spins with shape (N, N).
    i : int
        Row index of the spin.
    j : int
        Column index of the spin.

    Returns
    -------
    dH : float
        Energy difference ΔH = H_new - H_old for flipping s_{i,j}.
    """
    N = lattice.shape[0]
    spin = lattice[i, j]

    # Periodic boundary conditions: neighbors up, down, left, right
    up = lattice[(i - 1) % N, j]
    down = lattice[(i + 1) % N, j]
    left = lattice[i, (j - 1) % N]
    right = lattice[i, (j + 1) % N]

    neighbors = up + down + left + right

    # For H = -sum_{<i,j>} s_i s_j, flipping one spin gives
    # ΔH = 2 * s_ij * sum_{nn} s_nn
    dH = 2.0 * spin * neighbors

    return dH


# ============================================================
# Step 2: Calculate the dE_t flipped spin (end)
# ============================================================


# ============================================================
# Step 3: Single update of Metropolis, repeat it for each sweep. (begin)
# ============================================================
def metropolis_single_flip(lattice, beta):
    """
    Perform a single Metropolis trial:
    - choose a random spin
    - compute ΔH
    - accept/reject according to Metropolis rule.

    Warning the function also change the pointer so the info in the lattice pointer is already changed
    """

    N = lattice.shape[0]

    # Step 2: flip a random spin, conceptually
    i, j = np.random.randint(0, N, size=2)

    # Compute Energy change of flipped spin
    dH = compute_energy_change(lattice, i, j)

    # Metropolis
    if dH <= 0:
        # Energetically favourable: always accept
        lattice[i, j] *= -1
    else:
        # Accept with probability p = exp(-β ΔH)
        p = np.exp(-beta * dH)
        if np.random.rand() < p:
            lattice[i, j] *= -1
    return lattice


def metropolis_update(lattice, beta):
    """
    Perform one Metropolis *sweep* on the lattice.

    A sweep consists of N*N single-spin Metropolis trials, where
    N is the linear system size.

    Parameters
    ----------
    lattice : np.ndarray
        The 2D lattice of spins.
    beta : float
        Inverse temperature (1 / T).

    Returns
    -------
    lattice : np.ndarray
        Updated lattice after one sweep.
    """
    N = lattice.shape[0]

    # one sweep: try N^2 flips
    for _ in range(N * N):
        metropolis_single_flip(lattice, beta)

    return lattice


# ============================================================
# Step 3: single update of Metropolis, repeat it for each sweep. (end)
# ============================================================


# ============================================================
# Step 4: Average magnetization (begin)
# ============================================================

def compute_magnetization(lattice):
    """
    Calculate the total magnetization of the lattice.

    Parameters
    ----------
    lattice : np.ndarray
        The 2D lattice of spins.

    Returns
    -------
    M : float
        Total magnetization M = sum_{i,j} s_{i,j}.
    """
    return np.sum(lattice, dtype=np.float64)


# Metropolis simulation
def simulate_ising(N, beta_range, n_samples, tol):
    """
    Simulate the Ising model using Metropolis algorithm and compute observables.
    Parameters:
        N (int): Lattice size (N x N).
        beta_range (list): Range of inverse temperatures (1/T).
        n_samples (int): Number of samples to compute observables.
        tol (float): Tolerance for error calculation.
    Returns:
        list, list: Mean magnetizations squared and their errors for each beta.
    """
    magnetizations = []
    mag_errors = []
    energies = []
    specific_heats = []

    for beta in tqdm(beta_range, desc="Metropolis Simulating"):

        # Step 1: initialize lattice (cold start)
        lattice = initialize_lattice(N, mode="cold")

        # Thermalize the lattice: repeat 1000 sweeps
        for _ in range(1000):
            lattice = metropolis_update(lattice, beta)

        # Sampling
        squared_magnetization_samples = []
        energy_samples = []
        squared_energy_samples = []

        for _ in range(n_samples):
            lattice = metropolis_update(lattice, beta)

            magnetization = compute_magnetization(lattice)
            energy = compute_energy(lattice)

            squared_magnetization_samples.append(magnetization ** 2)
            energy_samples.append(energy)
            squared_energy_samples.append(energy ** 2)

        # Magnetization statistics
        mean_M2 = np.mean(squared_magnetization_samples)
        var_M2 = np.var(squared_magnetization_samples)
        mag_error = np.sqrt(var_M2 / n_samples)

        # Energy statistics
        mean_E = np.mean(energy_samples)
        mean_E2 = np.mean(squared_energy_samples)

        # Specific heat per spin: C = β^2 / N^2 * Var(H)
        var_E = mean_E2 - mean_E ** 2
        C = (beta ** 2) * var_E / (N * N)

        magnetizations.append(mean_M2)
        mag_errors.append(mag_error)
        energies.append(mean_E)
        specific_heats.append(C)

    return magnetizations, mag_errors, energies, specific_heats


# ============================================================
# Compute total energy H of a given configuration (begin)
# ============================================================
def compute_energy(lattice):
    """
    Compute the total energy H of the 2D Ising lattice with
    nearest-neighbor interactions, J = 1, periodic boundary conditions.

    Hamiltonian:
        H = - sum_{<i,j>} s_i s_j

    We sum over each site and only count interactions to
    the right and down neighbors to avoid double-counting.

    Parameters
    ----------
    lattice : np.ndarray
        The 2D lattice of spins, shape (N, N).

    Returns
    -------
    H : float
        Total energy of the configuration.
    """
    N = lattice.shape[0]
    H = 0.0

    for i in range(N):
        for j in range(N):
            s = lattice[i, j]

            up = lattice[(i - 1) % N, j]
            down = lattice[(i + 1) % N, j]
            left = lattice[i, (j - 1) % N]
            right = lattice[i, (j + 1) % N]

            neighbors = up+down+left+right
            H += - s * neighbors


    return H/2 # adjusted (Each pair counted twice)

# ============================================================
# Compute total energy H of a given configuration (end)
# ============================================================


def plot_results(beta_range, magnetizations, errors, N):
    """
    Plot magnetization squared vs temperature with error bars.
    """
    temperatures = 1 / np.array(beta_range)
    plt.errorbar(temperatures, magnetizations, yerr=errors, fmt='o', label=f"N={N}")
    plt.xlabel("Temperature (T)")
    plt.ylabel(r"$\mathbb{E}[M^2(S)]$")
    plt.title("Magnetization vs Temperature")
    plt.legend()
    plt.grid()
    plt.show()


# ========
# ============================================================
#  two different estimation of Tc  (begin)
# ============================================================
def estimate_tc_from_magnetization(beta_range, magnetizations):
    """
    Unstable estimator:
        Use the maximum slope of <M^2> vs T (or β) to define Tc.

    This method is very sensitive to noise, and we keep it
    here mainly for comparison in the report.
    """
    # magnetizations is a function of beta, but we want derivative wrt T or beta.
    # Here we keep it simple: derivative wrt beta.
    grad = np.gradient(magnetizations, beta_range)
    idx = np.argmax(np.abs(grad))  # position of largest slope
    Tc_est = 1.0 / beta_range[idx]
    return Tc_est


def estimate_tc_from_specific_heat(beta_range, specific_heats):
    """
    Stable estimator:
        Define Tc as the temperature where the specific heat C(T)
        reaches its maximum.
    """
    idx = np.argmax(specific_heats)
    Tc_est = 1.0 / beta_range[idx]
    return Tc_est
# ============================================================
#  two different estimation of Tc (end)
# ============================================================


def critical_temperature_vs_size(N_values, beta_range, n_samples, tol):
    """
    Compare two different estimators of Tc as a function of system size N:

        1) Tc_mag: from the slope of <M^2> (unstable)
        2) Tc_C  : from the peak of specific heat C(T) (stable)

    and plot both on the same figure.
    """
    Tc_from_mag = []
    Tc_from_C = []

    for N in N_values:
        magnetizations, mag_errors, energies, specific_heats = simulate_ising(
            N, beta_range, n_samples, tol
        )

        Tc_mag = estimate_tc_from_magnetization(beta_range, magnetizations)
        Tc_C = estimate_tc_from_specific_heat(beta_range, specific_heats)

        Tc_from_mag.append(Tc_mag)
        Tc_from_C.append(Tc_C)

    Tc_from_mag = np.array(Tc_from_mag)
    Tc_from_C = np.array(Tc_from_C)

    #
    plt.figure(figsize=(7, 4))
    plt.plot(N_values, Tc_from_mag, "o--", label=r"$T_c$ from $\nabla\langle M^2\rangle$ (noisy)")
    plt.plot(N_values, Tc_from_C, "s-", label=r"$T_c$ from $C(T)$ peak (stable)")
    plt.xlabel(r"Lattice Size $N$")
    plt.ylabel(r"Critical Temperature $T_c$")
    plt.title("Critical Temperature vs Lattice Size (Two Estimators)")
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()

    return Tc_from_mag, Tc_from_C

def plot_energy_vs_temperature(beta_range, energies, N):
    """
    Plot average energy <H> as a function of temperature T = 1 / beta.
    """
    temperatures = 1.0 / np.array(beta_range)

    plt.figure(figsize=(6, 4))
    plt.plot(temperatures, energies, "o-", label=f"N={N}")
    plt.xlabel("Temperature $T$")
    plt.ylabel(r"Average Energy $\langle H \rangle$")
    plt.title("Energy vs Temperature")
    plt.grid(True)
    plt.legend()
    plt.tight_layout()
    plt.show()


def plot_specific_heat_vs_temperature(beta_range, specific_heats, N):
    """
    Plot specific heat C(T) as a function of temperature T = 1 / beta.
    """
    temperatures = 1.0 / np.array(beta_range)

    plt.figure(figsize=(6, 4))
    plt.plot(temperatures, specific_heats, "o-", label=f"N={N}")
    plt.xlabel("Temperature $T$")
    plt.ylabel(r"Specific Heat $C(T)$")
    plt.title("Specific Heat vs Temperature")
    plt.grid(True)
    plt.legend()
    plt.tight_layout()
    plt.show()


if __name__ == "__main__":
    N = 20
    beta_range = np.linspace(0.2, 0.7, 40)
    n_samples = 500
    tol = 0.01

    magnetizations, mag_errors, energies, specific_heats = simulate_ising(
        N, beta_range, n_samples, tol
    )

    # 1. Magnetization vs Temperature (you already had)
    plot_results(beta_range, magnetizations, mag_errors, N)

    # 2. NEW: Energy vs Temperature
    plot_energy_vs_temperature(beta_range, energies, N)

    # 3. NEW: Specific Heat vs Temperature
    plot_specific_heat_vs_temperature(beta_range, specific_heats, N)

    # 4. (Optional) Tc vs N, with both estimators
    N_values = [10, 20, 30, 40]
    Tc_mag, Tc_C = critical_temperature_vs_size(N_values, beta_range, n_samples, tol)
